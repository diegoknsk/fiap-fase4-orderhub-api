name: Deploy OrderHub Application

on:
  workflow_run:
    workflows: ["PR - Build, Test, Sonar"]
    types:
      - completed
    branches:
      - main
  # Security: Only allow workflow_run from main branch to prevent execution of untrusted code from forks
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch para fazer deploy'
        required: false
        type: string
        default: ''
      run_migrator:
        description: 'Executar Migrator (padrão: não executar)'
        required: false
        type: boolean
        default: false

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: eks-fiap-fase4-infra
  KUBERNETES_NAMESPACE: orderhub
  DEPLOYMENT_NAME: orderhub-api
  CONTAINER_NAME: api
  ECR_REPOSITORY: fiap-fase4-infra-orderhub-api

jobs:
  check-quality:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: Check Quality Gate
        run: |
          echo "✅ Quality Gate passed - proceeding with deployment"
          echo "Workflow run: ${{ github.event.workflow_run.id }}"
          echo "Conclusion: ${{ github.event.workflow_run.conclusion }}"

  deploy:
    needs: check-quality
    if: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_repository.full_name == github.repository && github.event.workflow_run.head_branch == 'main' && github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    
    outputs:
      tag: ${{ steps.set-tag.outputs.tag }}
      api-image: ${{ steps.set-tag.outputs.api-image }}
      migrator-image: ${{ steps.set-tag.outputs.migrator-image }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4
      with:
        # Security: Always checkout from main branch for workflow_run events
        ref: 'main'
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@ff717079ee2060e4bcee96c4779b553acc87447c # v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@062b18b96a7aff071d4dc91bc00c4c1a7945b076 # v2
    
    - name: Set TAG and image names
      id: set-tag
      run: |
        TAG=$(git rev-parse --short HEAD)
        API_IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:api-${TAG}"
        MIGRATOR_IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:migrator-${TAG}"
        
        echo "tag=${TAG}" >> $GITHUB_OUTPUT
        echo "api-image=${API_IMAGE}" >> $GITHUB_OUTPUT
        echo "migrator-image=${MIGRATOR_IMAGE}" >> $GITHUB_OUTPUT
        
        echo "TAG: ${TAG}"
        echo "API Image: ${API_IMAGE}"
        echo "Migrator Image: ${MIGRATOR_IMAGE}"
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3
    
    - name: Build and push API image
      uses: docker/build-push-action@ca052bb54ab0790a636c9b5f226502c73d547a25 # v5
      with:
        context: .
        file: ./src/InterfacesExternas/FastFood.OrderHub.Api/Dockerfile
        push: true
        tags: |
          ${{ steps.set-tag.outputs.api-image }}
          ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:api-latest
        cache-from: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:api-latest
        cache-to: type=inline
    
    - name: Build and push Migrator image
      if: false
      uses: docker/build-push-action@ca052bb54ab0790a636c9b5f226502c73d547a25 # v5
      with:
        context: .
        file: ./src/InterfacesExternas/FastFood.OrderHub.Migrator/Dockerfile
        push: true
        tags: |
          ${{ steps.set-tag.outputs.migrator-image }}
          ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:migrator-latest
        cache-from: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:migrator-latest
        cache-to: type=inline
    
    - name: Configure kubectl
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
        kubectl version --client
    
    - name: Update ConfigMap
      run: |
        echo "Updating ConfigMap orderhub-config..."
        
        # Ler valores existentes do ConfigMap (se existir)
        EXISTING_COGNITO_REGION=$(kubectl get configmap orderhub-config -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.Authentication__Cognito__Region}' 2>/dev/null || echo "")
        EXISTING_JWT_ISSUER=$(kubectl get configmap orderhub-config -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.JwtCustomer__Issuer}' 2>/dev/null || echo "")
        EXISTING_JWT_AUDIENCE=$(kubectl get configmap orderhub-config -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.JwtCustomer__Audience}' 2>/dev/null || echo "")
        EXISTING_PAYMENT_BASE_URL=$(kubectl get configmap orderhub-config -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.PaymentService__BaseUrl}' 2>/dev/null || echo "")
        
        # Usar secret do GitHub se fornecido, senão usar valor existente, senão usar padrão
        COGNITO_REGION="${{ secrets.COGNITO__REGION }}"
        COGNITO_REGION=${COGNITO_REGION:-${EXISTING_COGNITO_REGION:-us-east-1}}
        JWT_ISSUER="${{ secrets.JWT__ISSUER }}"
        JWT_ISSUER=${JWT_ISSUER:-${EXISTING_JWT_ISSUER:-FastFood.Auth}}
        JWT_AUDIENCE="${{ secrets.JWT__AUDIENCE }}"
        JWT_AUDIENCE=${JWT_AUDIENCE:-${EXISTING_JWT_AUDIENCE:-FastFood.API}}
        PAYMENT_BASE_URL="${{ secrets.PAYMENT_SERVICE__BASE_URL }}"
        PAYMENT_BASE_URL=${PAYMENT_BASE_URL:-${EXISTING_PAYMENT_BASE_URL:-https://localhost:7088/}}
        
        kubectl create configmap orderhub-config \
          --from-literal=Authentication__Cognito__Region=${COGNITO_REGION} \
          --from-literal=Authentication__Cognito__ClockSkewMinutes=5 \
          --from-literal=JwtCustomer__Issuer=${JWT_ISSUER} \
          --from-literal=JwtCustomer__Audience=${JWT_AUDIENCE} \
          --from-literal=PaymentService__BaseUrl=${PAYMENT_BASE_URL} \
          --from-literal=PaymentService__TimeoutSeconds=30 \
          --from-literal=PaymentService__RetryEnabled=false \
          --from-literal=PaymentService__RetryCount=1 \
          --dry-run=client -o yaml | kubectl apply -f - -n ${{ env.KUBERNETES_NAMESPACE }}
        echo "ConfigMap updated successfully"
    
    - name: Update Secret
      run: |
        echo "Updating Secret orderhub-secrets..."
        
        # Ler valores existentes do Secret (se existir)
        EXISTING_COGNITO_USERPOOLID=$(kubectl get secret orderhub-secrets -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.Authentication__Cognito__UserPoolId}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
        EXISTING_COGNITO_CLIENTID=$(kubectl get secret orderhub-secrets -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.Authentication__Cognito__ClientId}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
        EXISTING_JWT_SECRET_KEY=$(kubectl get secret orderhub-secrets -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.JwtCustomer__SecretKey}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
        EXISTING_DYNAMODB_ACCESS_KEY=$(kubectl get secret orderhub-secrets -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.DynamoDb__AccessKey}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
        EXISTING_DYNAMODB_SECRET_KEY=$(kubectl get secret orderhub-secrets -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.DynamoDb__SecretKey}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
        EXISTING_DYNAMODB_SESSION_TOKEN=$(kubectl get secret orderhub-secrets -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.DynamoDb__SessionToken}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
        EXISTING_DYNAMODB_REGION=$(kubectl get secret orderhub-secrets -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.DynamoDb__Region}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
        EXISTING_DYNAMODB_SERVICE_URL=$(kubectl get secret orderhub-secrets -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.DynamoDb__ServiceUrl}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
        
        # Usar secret do GitHub se fornecido, senão usar valor existente
        COGNITO_USERPOOLID="${{ secrets.COGNITO__USERPOOLID }}"
        COGNITO_USERPOOLID=${COGNITO_USERPOOLID:-${EXISTING_COGNITO_USERPOOLID}}
        COGNITO_CLIENTID="${{ secrets.COGNITO__CLIENTID }}"
        COGNITO_CLIENTID=${COGNITO_CLIENTID:-${EXISTING_COGNITO_CLIENTID}}
        JWT_SECRET_KEY="${{ secrets.JWT__SECRET_KEY }}"
        JWT_SECRET_KEY=${JWT_SECRET_KEY:-${EXISTING_JWT_SECRET_KEY}}
        DYNAMODB_ACCESS_KEY="${{ secrets.DYNAMODB__ACCESS_KEY }}"
        DYNAMODB_ACCESS_KEY=${DYNAMODB_ACCESS_KEY:-${EXISTING_DYNAMODB_ACCESS_KEY}}
        DYNAMODB_SECRET_KEY="${{ secrets.DYNAMODB__SECRET_KEY }}"
        DYNAMODB_SECRET_KEY=${DYNAMODB_SECRET_KEY:-${EXISTING_DYNAMODB_SECRET_KEY}}
        DYNAMODB_SESSION_TOKEN="${{ secrets.DYNAMODB__SESSION_TOKEN }}"
        DYNAMODB_SESSION_TOKEN=${DYNAMODB_SESSION_TOKEN:-${EXISTING_DYNAMODB_SESSION_TOKEN}}
        DYNAMODB_REGION="${{ secrets.DYNAMODB__REGION }}"
        DYNAMODB_REGION=${DYNAMODB_REGION:-${EXISTING_DYNAMODB_REGION:-us-east-1}}
        DYNAMODB_SERVICE_URL="${{ secrets.DYNAMODB__SERVICE_URL }}"
        DYNAMODB_SERVICE_URL=${DYNAMODB_SERVICE_URL:-${EXISTING_DYNAMODB_SERVICE_URL}}
        
        kubectl create secret generic orderhub-secrets \
          --from-literal=Authentication__Cognito__UserPoolId=${COGNITO_USERPOOLID} \
          --from-literal=Authentication__Cognito__ClientId=${COGNITO_CLIENTID} \
          --from-literal=JwtCustomer__SecretKey=${JWT_SECRET_KEY} \
          --from-literal=DynamoDb__AccessKey=${DYNAMODB_ACCESS_KEY} \
          --from-literal=DynamoDb__SecretKey=${DYNAMODB_SECRET_KEY} \
          --from-literal=DynamoDb__SessionToken=${DYNAMODB_SESSION_TOKEN} \
          --from-literal=DynamoDb__Region=${DYNAMODB_REGION} \
          --from-literal=DynamoDb__ServiceUrl=${DYNAMODB_SERVICE_URL} \
          --dry-run=client -o yaml | kubectl apply -f - -n ${{ env.KUBERNETES_NAMESPACE }}
        echo "Secret updated successfully"
    
    - name: Update API deployment
      run: |
        echo "Updating ${DEPLOYMENT_NAME} deployment with new image..."
        kubectl set image deployment/${DEPLOYMENT_NAME} ${CONTAINER_NAME}=${{ steps.set-tag.outputs.api-image }} -n ${{ env.KUBERNETES_NAMESPACE }}
        
        echo "Waiting for rollout to complete..."
        kubectl rollout status deployment/${DEPLOYMENT_NAME} -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=300s
        
        echo "API deployment updated successfully"
    
    - name: Recreate Migrator job
      if: false
      run: |
        echo "Deleting existing migrator job if it exists..."
        kubectl delete job orderhub-migrator -n ${{ env.KUBERNETES_NAMESPACE }} --ignore-not-found=true
        
        echo "Waiting for job to be fully deleted..."
        sleep 10
        
        echo "Creating new migrator job..."
        cat <<EOF | kubectl apply -f -
        apiVersion: batch/v1
        kind: Job
        metadata:
          name: orderhub-migrator
          namespace: ${{ env.KUBERNETES_NAMESPACE }}
          labels:
            app: orderhub-migrator
            service: orderhub
        spec:
          completions: 1
          parallelism: 1
          backoffLimit: 3
          template:
            metadata:
              labels:
                app: orderhub-migrator
                service: orderhub
            spec:
              restartPolicy: Never
              containers:
              - name: migrator
                image: ${{ steps.set-tag.outputs.migrator-image }}
                imagePullPolicy: Always
                resources:
                  requests:
                    cpu: "100m"
                    memory: "256Mi"
                  limits:
                    cpu: "500m"
                    memory: "512Mi"
                terminationGracePeriodSeconds: 30
                envFrom:
                - configMapRef:
                    name: orderhub-config
                - secretRef:
                    name: orderhub-secrets
                command: ["dotnet", "FastFood.OrderHub.Migrator.dll"]
        EOF
        
        echo "Waiting for migrator job to complete..."
        kubectl wait --for=condition=complete job/orderhub-migrator -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=600s
        
        echo "Migrator job completed successfully"
    
    - name: Verify deployment
      run: |
        echo "Verifying deployment..."
        kubectl get deployment ${DEPLOYMENT_NAME} -n ${{ env.KUBERNETES_NAMESPACE }}
        kubectl get pods -l app=orderhub-api -n ${{ env.KUBERNETES_NAMESPACE }}
        echo "Deployment verified successfully!"

  deploy-manual:
    # Manual deployment from any branch
    if: ${{ github.event_name == 'workflow_dispatch' && github.repository_owner != '' }}
    runs-on: ubuntu-latest
    
    outputs:
      tag: ${{ steps.set-tag.outputs.tag }}
      api-image: ${{ steps.set-tag.outputs.api-image }}
      migrator-image: ${{ steps.set-tag.outputs.migrator-image }}
    
    steps:
    - name: Determine branch to checkout
      id: branch-checkout
      run: |
        if [ -n "${{ github.event.inputs.branch }}" ]; then
          BRANCH="${{ github.event.inputs.branch }}"
        else
          BRANCH="${{ github.ref_name }}"
        fi
        echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
        echo "Checking out branch: ${BRANCH}"
    
    - name: Checkout code
      uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4
      with:
        ref: ${{ steps.branch-checkout.outputs.branch }}
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@ff717079ee2060e4bcee96c4779b553acc87447c # v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@062b18b96a7aff071d4dc91bc00c4c1a7945b076 # v2
    
    - name: Set TAG and image names
      id: set-tag
      run: |
        TAG=$(git rev-parse --short HEAD)
        API_IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:api-${TAG}"
        MIGRATOR_IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:migrator-${TAG}"
        
        echo "tag=${TAG}" >> $GITHUB_OUTPUT
        echo "api-image=${API_IMAGE}" >> $GITHUB_OUTPUT
        echo "migrator-image=${MIGRATOR_IMAGE}" >> $GITHUB_OUTPUT
        
        echo "TAG: ${TAG}"
        echo "API Image: ${API_IMAGE}"
        echo "Migrator Image: ${MIGRATOR_IMAGE}"
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3
    
    - name: Build and push API image
      uses: docker/build-push-action@ca052bb54ab0790a636c9b5f226502c73d547a25 # v5
      with:
        context: .
        file: ./src/InterfacesExternas/FastFood.OrderHub.Api/Dockerfile
        push: true
        tags: |
          ${{ steps.set-tag.outputs.api-image }}
          ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:api-latest
        cache-from: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:api-latest
        cache-to: type=inline
    
    - name: Build and push Migrator image
      if: ${{ github.event.inputs.run_migrator == true }}
      uses: docker/build-push-action@ca052bb54ab0790a636c9b5f226502c73d547a25 # v5
      with:
        context: .
        file: ./src/InterfacesExternas/FastFood.OrderHub.Migrator/Dockerfile
        push: true
        tags: |
          ${{ steps.set-tag.outputs.migrator-image }}
          ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:migrator-latest
        cache-from: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:migrator-latest
        cache-to: type=inline
    
    - name: Configure kubectl
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
        kubectl version --client
    
    - name: Update ConfigMap
      run: |
        echo "Updating ConfigMap orderhub-config..."
        
        # Ler valores existentes do ConfigMap (se existir)
        EXISTING_COGNITO_REGION=$(kubectl get configmap orderhub-config -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.Authentication__Cognito__Region}' 2>/dev/null || echo "")
        EXISTING_JWT_ISSUER=$(kubectl get configmap orderhub-config -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.JwtCustomer__Issuer}' 2>/dev/null || echo "")
        EXISTING_JWT_AUDIENCE=$(kubectl get configmap orderhub-config -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.JwtCustomer__Audience}' 2>/dev/null || echo "")
        EXISTING_PAYMENT_BASE_URL=$(kubectl get configmap orderhub-config -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.PaymentService__BaseUrl}' 2>/dev/null || echo "")
        
        # Usar secret do GitHub se fornecido, senão usar valor existente, senão usar padrão
        COGNITO_REGION="${{ secrets.COGNITO__REGION }}"
        COGNITO_REGION=${COGNITO_REGION:-${EXISTING_COGNITO_REGION:-us-east-1}}
        JWT_ISSUER="${{ secrets.JWT__ISSUER }}"
        JWT_ISSUER=${JWT_ISSUER:-${EXISTING_JWT_ISSUER:-FastFood.Auth}}
        JWT_AUDIENCE="${{ secrets.JWT__AUDIENCE }}"
        JWT_AUDIENCE=${JWT_AUDIENCE:-${EXISTING_JWT_AUDIENCE:-FastFood.API}}
        PAYMENT_BASE_URL="${{ secrets.PAYMENT_SERVICE__BASE_URL }}"
        PAYMENT_BASE_URL=${PAYMENT_BASE_URL:-${EXISTING_PAYMENT_BASE_URL:-https://localhost:7088/}}
        
        kubectl create configmap orderhub-config \
          --from-literal=Authentication__Cognito__Region=${COGNITO_REGION} \
          --from-literal=Authentication__Cognito__ClockSkewMinutes=5 \
          --from-literal=JwtCustomer__Issuer=${JWT_ISSUER} \
          --from-literal=JwtCustomer__Audience=${JWT_AUDIENCE} \
          --from-literal=PaymentService__BaseUrl=${PAYMENT_BASE_URL} \
          --from-literal=PaymentService__TimeoutSeconds=30 \
          --from-literal=PaymentService__RetryEnabled=false \
          --from-literal=PaymentService__RetryCount=1 \
          --dry-run=client -o yaml | kubectl apply -f - -n ${{ env.KUBERNETES_NAMESPACE }}
        echo "ConfigMap updated successfully"
    
    - name: Update Secret
      run: |
        echo "Updating Secret orderhub-secrets..."
        
        # Ler valores existentes do Secret (se existir)
        EXISTING_COGNITO_USERPOOLID=$(kubectl get secret orderhub-secrets -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.Authentication__Cognito__UserPoolId}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
        EXISTING_COGNITO_CLIENTID=$(kubectl get secret orderhub-secrets -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.Authentication__Cognito__ClientId}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
        EXISTING_JWT_SECRET_KEY=$(kubectl get secret orderhub-secrets -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.JwtCustomer__SecretKey}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
        EXISTING_DYNAMODB_ACCESS_KEY=$(kubectl get secret orderhub-secrets -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.DynamoDb__AccessKey}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
        EXISTING_DYNAMODB_SECRET_KEY=$(kubectl get secret orderhub-secrets -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.DynamoDb__SecretKey}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
        EXISTING_DYNAMODB_SESSION_TOKEN=$(kubectl get secret orderhub-secrets -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.DynamoDb__SessionToken}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
        EXISTING_DYNAMODB_REGION=$(kubectl get secret orderhub-secrets -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.DynamoDb__Region}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
        EXISTING_DYNAMODB_SERVICE_URL=$(kubectl get secret orderhub-secrets -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.data.DynamoDb__ServiceUrl}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
        
        # Usar secret do GitHub se fornecido, senão usar valor existente
        COGNITO_USERPOOLID="${{ secrets.COGNITO__USERPOOLID }}"
        COGNITO_USERPOOLID=${COGNITO_USERPOOLID:-${EXISTING_COGNITO_USERPOOLID}}
        COGNITO_CLIENTID="${{ secrets.COGNITO__CLIENTID }}"
        COGNITO_CLIENTID=${COGNITO_CLIENTID:-${EXISTING_COGNITO_CLIENTID}}
        JWT_SECRET_KEY="${{ secrets.JWT__SECRET_KEY }}"
        JWT_SECRET_KEY=${JWT_SECRET_KEY:-${EXISTING_JWT_SECRET_KEY}}
        DYNAMODB_ACCESS_KEY="${{ secrets.DYNAMODB__ACCESS_KEY }}"
        DYNAMODB_ACCESS_KEY=${DYNAMODB_ACCESS_KEY:-${EXISTING_DYNAMODB_ACCESS_KEY}}
        DYNAMODB_SECRET_KEY="${{ secrets.DYNAMODB__SECRET_KEY }}"
        DYNAMODB_SECRET_KEY=${DYNAMODB_SECRET_KEY:-${EXISTING_DYNAMODB_SECRET_KEY}}
        DYNAMODB_SESSION_TOKEN="${{ secrets.DYNAMODB__SESSION_TOKEN }}"
        DYNAMODB_SESSION_TOKEN=${DYNAMODB_SESSION_TOKEN:-${EXISTING_DYNAMODB_SESSION_TOKEN}}
        DYNAMODB_REGION="${{ secrets.DYNAMODB__REGION }}"
        DYNAMODB_REGION=${DYNAMODB_REGION:-${EXISTING_DYNAMODB_REGION:-us-east-1}}
        DYNAMODB_SERVICE_URL="${{ secrets.DYNAMODB__SERVICE_URL }}"
        DYNAMODB_SERVICE_URL=${DYNAMODB_SERVICE_URL:-${EXISTING_DYNAMODB_SERVICE_URL}}
        
        kubectl create secret generic orderhub-secrets \
          --from-literal=Authentication__Cognito__UserPoolId=${COGNITO_USERPOOLID} \
          --from-literal=Authentication__Cognito__ClientId=${COGNITO_CLIENTID} \
          --from-literal=JwtCustomer__SecretKey=${JWT_SECRET_KEY} \
          --from-literal=DynamoDb__AccessKey=${DYNAMODB_ACCESS_KEY} \
          --from-literal=DynamoDb__SecretKey=${DYNAMODB_SECRET_KEY} \
          --from-literal=DynamoDb__SessionToken=${DYNAMODB_SESSION_TOKEN} \
          --from-literal=DynamoDb__Region=${DYNAMODB_REGION} \
          --from-literal=DynamoDb__ServiceUrl=${DYNAMODB_SERVICE_URL} \
          --dry-run=client -o yaml | kubectl apply -f - -n ${{ env.KUBERNETES_NAMESPACE }}
        echo "Secret updated successfully"
    
    - name: Update API deployment
      run: |
        echo "Updating ${DEPLOYMENT_NAME} deployment with new image..."
        kubectl set image deployment/${DEPLOYMENT_NAME} ${CONTAINER_NAME}=${{ steps.set-tag.outputs.api-image }} -n ${{ env.KUBERNETES_NAMESPACE }}
        
        echo "Waiting for rollout to complete..."
        kubectl rollout status deployment/${DEPLOYMENT_NAME} -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=300s
        
        echo "API deployment updated successfully"
    
    - name: Recreate Migrator job
      if: ${{ github.event.inputs.run_migrator == true }}
      run: |
        echo "Deleting existing migrator job if it exists..."
        kubectl delete job orderhub-migrator -n ${{ env.KUBERNETES_NAMESPACE }} --ignore-not-found=true
        
        echo "Waiting for job to be fully deleted..."
        sleep 10
        
        echo "Creating new migrator job..."
        cat <<EOF | kubectl apply -f -
        apiVersion: batch/v1
        kind: Job
        metadata:
          name: orderhub-migrator
          namespace: ${{ env.KUBERNETES_NAMESPACE }}
          labels:
            app: orderhub-migrator
            service: orderhub
        spec:
          completions: 1
          parallelism: 1
          backoffLimit: 3
          template:
            metadata:
              labels:
                app: orderhub-migrator
                service: orderhub
            spec:
              restartPolicy: Never
              containers:
              - name: migrator
                image: ${{ steps.set-tag.outputs.migrator-image }}
                imagePullPolicy: Always
                resources:
                  requests:
                    cpu: "100m"
                    memory: "256Mi"
                  limits:
                    cpu: "500m"
                    memory: "512Mi"
                terminationGracePeriodSeconds: 30
                envFrom:
                - configMapRef:
                    name: orderhub-config
                - secretRef:
                    name: orderhub-secrets
                command: ["dotnet", "FastFood.OrderHub.Migrator.dll"]
        EOF
        
        echo "Waiting for migrator job to complete..."
        kubectl wait --for=condition=complete job/orderhub-migrator -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=600s
        
        echo "Migrator job completed successfully"
    
    - name: Verify deployment
      run: |
        echo "Verifying deployment..."
        kubectl get deployment ${DEPLOYMENT_NAME} -n ${{ env.KUBERNETES_NAMESPACE }}
        kubectl get pods -l app=orderhub-api -n ${{ env.KUBERNETES_NAMESPACE }}
        if [ "${{ github.event.inputs.run_migrator }}" == "true" ]; then
          kubectl get job orderhub-migrator -n ${{ env.KUBERNETES_NAMESPACE }}
          kubectl get pods -l app=orderhub-migrator -n ${{ env.KUBERNETES_NAMESPACE }}
        fi
        echo "Deployment verified successfully!"
