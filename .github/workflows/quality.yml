name: PR - Build, Test, Sonar

on:
  pull_request:
    branches: [ "main" ]
    types: [opened, synchronize, reopened]
  push:
    branches: [ "main" ]

jobs:
  quality:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.ref || github.ref }}

      - name: Setup .NET
        uses: actions/setup-dotnet@67a3573c9a986a3f9c594539f4ab511d57bb3ce9 # v4
        with:
          dotnet-version: "8.0.x"

      - name: Cache Sonar
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
        with:
          path: ~/.sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar

      - name: Install SonarScanner for .NET
        run: dotnet tool install --global dotnet-sonarscanner

      - name: Sonar - Begin
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "=== Configuring SonarCloud for Pull Request ==="
            echo "PR Number: ${{ github.event.pull_request.number }}"
            echo "Head Ref: ${{ github.head_ref }}"
            echo "Base Ref: ${{ github.base_ref }}"
            echo "PR Branch: ${{ github.event.pull_request.head.ref }}"
            echo "Base Branch: ${{ github.event.pull_request.base.ref }}"
            echo "Repository: ${{ github.repository }}"
            echo ""
            echo "=== Checking for code changes ==="
            BASE_REF="${{ github.event.pull_request.base.ref }}"
            HEAD_REF="${{ github.event.pull_request.head.ref }}"
            echo "Fetching base branch: $BASE_REF"
            git fetch origin "$BASE_REF" || echo "Could not fetch base branch"
            echo "Changed files:"
            git diff --name-only "origin/$BASE_REF"...HEAD 2>/dev/null || git diff --name-only "$BASE_REF"...HEAD 2>/dev/null || echo "Could not determine changed files"
            echo ""
            echo "C# files changed:"
            git diff --name-only "origin/$BASE_REF"...HEAD 2>/dev/null | grep -E '\.(cs|csproj)$' || git diff --name-only "$BASE_REF"...HEAD 2>/dev/null | grep -E '\.(cs|csproj)$' || echo "No .cs or .csproj files changed in this PR"
            dotnet-sonarscanner begin \
              /k:"diegoknsk_fiap-fase4-orderhub-api" \
              /o:"diegoknsk" \
              /d:sonar.token="$SONAR_TOKEN" \
              /d:sonar.cs.opencover.reportsPaths="TestResults/coverage/coverage.opencover.xml" \
              /d:sonar.coverage.exclusions="**/*Program.cs,**/*Startup.cs,**/Migrations/**,**/*Dto.cs" \
              /d:sonar.scanner.scanAll=false \
              /d:sonar.projectBaseDir="${{ github.workspace }}" \
              /d:sonar.sources="src" \
              /d:sonar.inclusions="**/*.cs" \
              /d:sonar.qualitygate.wait=true \
              /d:sonar.pullrequest.provider=github \
              /d:sonar.pullrequest.github.repository="${{ github.repository }}" \
              /d:sonar.pullrequest.key="${{ github.event.pull_request.number }}" \
              /d:sonar.pullrequest.branch="${{ github.event.pull_request.head.ref }}" \
              /d:sonar.pullrequest.base="${{ github.event.pull_request.base.ref }}"
          else
            echo "=== Configuring SonarCloud for Branch Analysis ==="
            dotnet-sonarscanner begin \
              /k:"diegoknsk_fiap-fase4-orderhub-api" \
              /o:"diegoknsk" \
              /d:sonar.token="$SONAR_TOKEN" \
              /d:sonar.cs.opencover.reportsPaths="TestResults/coverage/coverage.opencover.xml" \
              /d:sonar.coverage.exclusions="**/*Program.cs,**/*Startup.cs,**/Migrations/**,**/*Dto.cs" \
              /d:sonar.scanner.scanAll=false \
              /d:sonar.projectBaseDir="${{ github.workspace }}" \
              /d:sonar.sources="src" \
              /d:sonar.inclusions="**/*.cs" \
              /d:sonar.qualitygate.wait=true
          fi

      - name: Restore
        run: dotnet restore FastFood.OrderHub.sln

      - name: Build
        run: dotnet build FastFood.OrderHub.sln -c Release --no-restore /p:DebugType=portable /p:DebugSymbols=true

      - name: Test (Unit + BDD) with coverage
        run: |
          mkdir -p TestResults/coverage
          dotnet test FastFood.OrderHub.sln -c Release --no-build \
            --logger "trx;LogFileName=test_results.trx" \
            /p:CollectCoverage=true \
            /p:CoverletOutputFormat="opencover" \
            /p:CoverletOutput="TestResults/coverage/"

      - name: List coverage files
        run: |
          echo "=== Coverage files generated ==="
          find . -name "coverage.opencover.xml" -type f || echo "No coverage files found"
          echo ""
          echo "=== TestResults directory structure ==="
          ls -la TestResults/ || echo "TestResults directory not found"
          echo ""
          echo "=== TestResults/coverage directory structure ==="
          ls -la TestResults/coverage/ || echo "TestResults/coverage directory not found"
          echo ""
          echo "=== All TestResults subdirectories ==="
          find . -type d -name "TestResults" -exec ls -la {} \; || echo "No TestResults directories found"

      - name: Consolidate coverage reports
        run: |
          mkdir -p TestResults/coverage
          # Find all coverage files generated by Coverlet
          # Coverlet can generate files in different locations depending on configuration
          COVERAGE_FILES=$(find . -name "coverage.opencover.xml" -type f 2>/dev/null | grep -v ".git" || true)
          echo "=== Found coverage files ==="
          if [ -n "$COVERAGE_FILES" ]; then
            echo "$COVERAGE_FILES"
          else
            echo "No coverage files found with standard name, searching for any .xml in TestResults..."
            COVERAGE_FILES=$(find . -path "*/TestResults/**/*.xml" -type f 2>/dev/null | grep -v ".git" || true)
            if [ -n "$COVERAGE_FILES" ]; then
              echo "Found XML files in TestResults:"
              echo "$COVERAGE_FILES"
            fi
          fi
          
          if [ -n "$COVERAGE_FILES" ]; then
            # Count files (handle case where find returns single line)
            COVERAGE_COUNT=$(echo "$COVERAGE_FILES" | wc -l | tr -d ' ')
            echo "Found $COVERAGE_COUNT coverage file(s)"
            
            if [ "$COVERAGE_COUNT" -eq 1 ]; then
              # Single file, just copy it
              echo "Copying single coverage file..."
              cp "$COVERAGE_FILES" TestResults/coverage/coverage.opencover.xml
            else
              # Multiple files - find the largest one (most comprehensive)
              echo "Multiple coverage files found, selecting largest..."
              LARGEST_FILE=""
              LARGEST_SIZE=0
              for file in $COVERAGE_FILES; do
                SIZE=$(stat -c%s "$file" 2>/dev/null || echo "0")
                if [ "$SIZE" -gt "$LARGEST_SIZE" ]; then
                  LARGEST_SIZE=$SIZE
                  LARGEST_FILE="$file"
                fi
              done
              if [ -n "$LARGEST_FILE" ]; then
                echo "Using largest file: $LARGEST_FILE (size: $LARGEST_SIZE bytes)"
                cp "$LARGEST_FILE" TestResults/coverage/coverage.opencover.xml
              else
                # Fallback: use first file
                FIRST_FILE=$(echo "$COVERAGE_FILES" | head -n 1)
                echo "Using first file as fallback: $FIRST_FILE"
                cp "$FIRST_FILE" TestResults/coverage/coverage.opencover.xml
              fi
            fi
            
            echo "=== Coverage file consolidated ==="
            ls -lh TestResults/coverage/coverage.opencover.xml
            echo "File size: $(du -h TestResults/coverage/coverage.opencover.xml | cut -f1)"
            echo "File exists check:"
            test -f TestResults/coverage/coverage.opencover.xml && echo "✓ File exists" || echo "✗ File does not exist"
          else
            echo "ERROR: No coverage files found to consolidate"
            echo "Searching in common locations..."
            find . -type d -name "TestResults" -exec find {} -name "*.xml" \; 2>/dev/null || true
            echo "Checking if coverage was generated in expected location..."
            ls -la TestResults/coverage/ 2>/dev/null || echo "TestResults/coverage/ does not exist"
            exit 1
          fi

      - name: Verify coverage file before Sonar End
        run: |
          echo "=== Verifying coverage file ==="
          COVERAGE_PATH="TestResults/coverage/coverage.opencover.xml"
          if [ -f "$COVERAGE_PATH" ]; then
            echo "✓ Coverage file exists at $COVERAGE_PATH"
            ls -lh "$COVERAGE_PATH"
            echo "File size: $(du -h "$COVERAGE_PATH" | cut -f1)"
            echo "Absolute path: $(pwd)/$COVERAGE_PATH"
            echo "First 20 lines of coverage file:"
            head -n 20 "$COVERAGE_PATH"
            echo ""
            echo "=== Verifying file content ==="
            if grep -q "<CoverageSession>" "$COVERAGE_PATH"; then
              echo "✓ File contains valid OpenCover XML structure"
              # Count coverage entries
              COVERAGE_LINES=$(grep -c "<Summary" "$COVERAGE_PATH" || echo "0")
              echo "Coverage summary entries found: $COVERAGE_LINES"
            else
              echo "✗ File does not contain valid OpenCover XML structure"
              exit 1
            fi
          else
            echo "✗ Coverage file NOT found at $COVERAGE_PATH"
            echo "Current directory: $(pwd)"
            echo "Searching for coverage files..."
            find . -name "coverage.opencover.xml" -type f
            exit 1
          fi

      - name: Sonar - End
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: dotnet-sonarscanner end /d:sonar.token="$SONAR_TOKEN"
